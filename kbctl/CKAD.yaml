---
 ========================================================================================== 
                            CKAD
 ==========================================================================================
 CKAD:
    - links:
       - https://www.cncf.io/certification/ckad/
       - https://linuxacademy.com/course/certified-kubernetes-application-developer-ckad/
    - Core Concepts: 13%
    - Configuration: 18%
      Multi-Container Pods: 10%
      Observability: 18%
      Pod Design: 20%
    - Services & Networking: 13%
      State Persistence: 8%
---
 ==========================================================================================
                          CKAD - CURRICULUM
 ==========================================================================================

 CKAD-CURRICULUM:
    - 13% - Core Concepts:
        - Understand Kubernetes API primitives
        - Create and configure basic Pods
    - 18% - Configuration: 
        - Understand ConfigMaps
        - Understand SecurityContexts
        - Define an application’s resource requirements
        - Create & consume Secrets
        - Understand ServiceAccounts
    - 10% - Multi-Container Pods:
        - Understand Multi-Container Pod design patterns (e .g. ambassador, adapter, sidecare)
    - 18% - Observability:
        - Understand LivenessProbes and ReadinessProbes
        - Understand container logging
        - Understand how to monitor applications in Kubernetes
        - Understand debugging in Kubernetes
    - 20% - Pod Design:
        - Understand Deployments and how to perform rolling updates
        - Understand Deployments and how to perform rollbacks
        - Understand Jobs and CronJobs
        - Understand how to use Labels, Selectors,and Annotations
    - 13% - Service and Networking:
        - Understand Services
        - Demonstrate basic understanding of NetworkPolicies
    - 8% - State Persistence:
        - Understand PersistentVolumeClaims for storage

 =========================================================================================
                          CKAD - TOPICS
 ==========================================================================================

 CKAD-TOPICS:
    - 13% - Core Concepts:
        - Kubernetes Architecture
        - Create and Configure basic Pods
    - 18% - Configuration: 
        - Config Maps
        - Security Contexts
        - Resource Requirements
        - secrets
        - Service Accounts
    - 10% - Multi-Container Pods:
        - Ambassdor
        - Adapter
        - SideCar
    - 18% - Observability:
        - ReadinessProbe
        - LivenessProbe
        - Container Logging
        - Monitor And Debug Applications
    - 20% - Pod Design:
        - labels, selectors, Annotations
        - Rolling Updates, Rollbacks in Deployments
        - Jobs and Cron Jobs
    - 13% - Service and Networking:
        - Understading Services
        - Network Policies
    - 8% - State Persistence:
        - persistence Volumes
        - persistence Volume Claims
 ==========================================================================================
 
=========================================================================================
    1 - 1/2              1-1    CKAD - Core Concepts - Kubernetes Architecture - 13%
==========================================================================================

 Kubernetes-Architecture:
    - Master:
       - ETCD CLUSTER: 
           - its a database which store data in key:value Pair
           - it runs on port no: 2379 (by default)
           - It stores the cluster details
           - The etcd cluster stores info about:
              - nodes
              - pods
              - configs
              - secrets
              - Accounts
              - Roles
              - Bindings
              - Others
       - Kube API server: 
             - accepts all requests and processing
             - Authenticate User -> Validate request -> Retreive data -> Update ETCD 
               -> Schedulers -> Kubelet -> then pods and containers are created and run by Kubelet
       - Kube Control manager: 
              - namespaces controller:    
              - service account controller:
              - Node controller: 
                 - checks node  Availability
                 - node controller checks status of nodes
                 - watch status of nodes
                 - remidiate situtation
                 - Node Monitor period: 5s
                   - checks every 5 secs if not reachable then
                 - Node Monitor grace period: 40s
                   - waits for 40 sec to mark node as unhealthy/unreachable
                 - Pod eviction time: 5m
                   - waits for 5 min. to restore pods to normal state,
                     if not restored then remove pods and provision them to healthy node.

              - Replication controller: checks desired no of pods are runnning
              - Replica-set:
              - Deployemnt controller:                        
              - endpoint controller:              
              - PV-Protection controller:
              - PV-Binder controller:              
              - Stateful-set:
              - job controller:
              - cron job:

       - Kube Schdeuler: 
          - places the right containers on right node based on available node resources like ram, cpu

    - Worker:
       - Kubelet: it is the agent runnning on the node
           - it registers the node with kubernetes cluster
           - create pods / containers
           - Monitor nodes and pods and reports to api sever
           - An agent that runs on each node in the cluster. 
           - It makes sure that containers are running in a pod.
           - The kubelet takes a set of PodSpecs that are provided through various mechanisms 
             and ensures that the containers described in those PodSpecs are running and healthy. 
           - The kubelet doesn’t manage containers which were not created by Kubernetes.
       - Kubeproxy: 
           - kube-proxy is a network proxy that runs on each node in your cluster, 
             implementing part of the Kubernetes Service concept.
           - kube-proxy maintains network rules on nodes. 
           - These network rules allow network communication to yourPods from network sessions 
             inside or outside of your cluster.
           - create route tables
           - enables service to connect with other pods using service namespaces

    PORT_NUMBERS:
      - MASTER:
         - kube-api: 6443
         - kubelet: 10250
         - Kube-scheduler: 10251
         - Kube-controller-manager: 10252
         - ETCD: 2379
         - ETCD: 2380 #INCASE OF MULTIPLE MASTERS
      - Node:
          - Services: 30000-32767
          - kubelet: 10250

 =========================================================================================
    1 - 2/2        1-2    CKAD - Core Concepts - Create and Configure basic Pods -13%
 ==========================================================================================

 Pod: 
  - It is the basic kubernetes Object. It has containers runnning inside it and pods are run in
      kubernetes Cluster.
  - By default each pod is associated with default Service Account  and
    default namespaces unless explicitly mentioned    

 Manifest File for Pod:
  -------------------pod-def.yaml--------------------------------------------
   apiVersion: v1
   kind: Pod 
   metadata: 
     name: myapp-pod   
     labels:
       app: myapp
       type: front-end    
   spec:
     containers:
       - name: nginx-webserver
         image: nginx
         ports:
           - containerPort: 80
  ----------------------------------------------------------------------------

 COMMANDS:

   - To create the pod using Manifest File:
       kubectl create -f pod-def.yaml
   - To generate the above pod Manifest file in yaml format and redirect it's output to a file:
       kubectl run myapp-pod --image=nginx --restart=Never -o yaml --dry-run > pod-def.yaml
   - To see the list of pods running in default namespace:
       kubectl get pods
       #or 
       kubectl get po
   - To create pod in a specific namespace (say dev):
       kubectl --namespace=dev create -f pod-def.yml 
       #or
       kubectl -n dev create -f pod-def.yaml
   - To see list of pods with detailed information like on which node it's running:
       kubectl get pods -o wide
   - To see list of pods with detailed information like on which node it's running Across all namespaces:
       kubectl get pods -o wide -A #works with v1.14 +
       #or
       kubectl get pods -o wide --all-namespaces
   - To see detailed information of pods like labels, containers, created time, events etc:
       kubectl describe pods <pod-name> #check the metadata name section for pod name.
   - To remove the pod by name:
       kubectl delete pods <pod-name> 
   - To remove all the pods :
       kubectl delete pods --all
   - To Delete pods and services with label name=myLabel:
       kubectl delete pods,services -l name=myLabel
       #ex: kubectl delete pods,services -l env=dev

 #Edit a POD
 #Remember, you CANNOT edit specifications of an existing POD other than the below.
 #spec.containers[*].image
 #spec.initContainers[*].image
 #spec.activeDeadlineSeconds
 #spec.tolerations

 #Run the kubectl edit pod <pod name> command.  This will open the pod specification in an editor (vi editor). 
 #Then edit the required properties. When you try to save it, you will be denied. 
 #This is because you are attempting to edit a field on the pod that is not editable.
 # A copy of the file with your changes is saved in a temporary location /tmp/pod093e2e.yaml

 =========================================================================================
      2 - 1/5          2-1    CKAD - Configuration - ConfigMaps - 18%
 ==========================================================================================

 Config Maps: it is used to store configuration data for applications.

 ConfigMaps Manifest file:

 -----Config-Map.yml:----------------
 ---  
 apiVersion: v1
 kind: ConfigMap
 metadata:
   name: app-config
 data:
   APP_COLOR: pink
   APP_MOD: prod  
-----------------------------------------

COMMANDS:
  - To create ConfigMap from Manifest file:
     kubectl create -f Config-Map.yaml

  - To generate the above ConfigMap Manifest file in yaml format and redirect it's output to a file:
     kubectl create configmap <confg-name> --from-literal=<key>=<value>  -o yaml --dry-run > Config-Map.yml

     ex:  kubectl create configmap app-config --from-literal=APP_COLOR=pink   \
         --from-literal=APP_MOD=prod -o yaml --dry-run > Config-Map.yaml

  - To generate the above ConfigMap Manifest file in yaml format and redirect it's output to a file:         
    kubectl create configmap <confg-name> --from-file=<path-to-file> -o yaml --dry-run > config-map.yaml
    #ex:  kubectl create configmap my-config --from-file=app_config.properties
     --- 
     #app_config.properties
     APP_COLOR=pink
     APP_MOD=prod
     -----------------------
     
  - To see the list of configmaps:
     kubectl get cm
     #or
     kubectl get configmaps
  - To see detailed view of configMaps:
     kubectl describe configmap

  Usage:
  
  - To utilize the configmap in POD as environment variables:
    ---------------------------------------------------------------
      apiVersion: v1
      kind: Pod
      metadata:
        name: app-config
      spec:
        contianers:
          - name:
            image:
         #  env:
         #  - name: APP_COLOR
         #     valueFrom:
         #       ConfigMapKeyRef:
         #         name: app-config
         #         key: APP_COLOR
                  
            envFrom:
             - configMapRef:
                     name: app-config
    --------------------------------------------------------------
     
     - To Populate a Volume with data stored in a ConfigMap     

    --------------------------------------------------------------
    #pods/pod-configmap-volume.yaml 
    apiVersion: v1
    kind: Pod
    metadata:
      name: api-test-pod
    spec:
      containers:
       - name: test-container
         image: k8s.gcr.io/busybox
         command: [ "/bin/sh", "-c", "ls /etc/config/" ]
         volumeMounts:
           - name: config-volume
             mountPath: /etc/config
      volumes:
        - name: config-volume
          configMap:
              name: special-config
      restartPolicy: Never

    --------------------------------------------------------------
  =========================================================================================
    2 - 2/5          2-2    CKAD - Configuration - Security Contexts - 18%
 =========================================================================================
 
  SecurityContexts: It is used to give user permissions.

     - pod-level-security:
     -----------------------------------------------------
       #To use security contexts in pod level in kubernetes in pod-def.yaml
        apiVersion: v1
        kind: Pod
        metadata:
          name: nginx-pod
        spec:
          securityContext:
            runAsUser: 1001
            runAsGroup: 3000
            fsGroup: 2000  
          container:
            - name: nginx
              image: private-registry.io/apps/internal-app
          imagePullSecret:
            - name: regcred #check below command to create regcred
       -----------------------------------------------------

    - container-level-security:
      -----------------------------------------------------
       #To use security contexts in container level in kubernetes in pod-def.yaml
       #note: capabilities can be added only at container level
        apiVersion: v1
        kind: Pod
        metadata:
          name: nginx-pod
        spec:                 
          container:
            - name: nginx
              image: private-registry.io/apps/internal-app
              securityContext:
                 runAsUser: 1001
                 capabilities: 
                   add: [ "MAC_ADMIN" ]
          imagePullSecret:
            - name: regcred #check below command to create regcred
       -----------------------------------------------------

  ----------------------------------------------------
   kubectl create secret docker-registery regcred \
   --docker-server=private-registry.io \
   --docker-username=registry-user \
   --docker-password=registry-pass \
   --docker-email=registry-user@org.com
  -----------------------------------------------------

 =========================================================================================
    2 - 3/5          2-3    CKAD - Configuration - Resource Requirements - 18%
 =========================================================================================
   
Resource Requirements: These are cpu and memory usage limits set on the pod.

    If you do not specify a CPU limit for a Container, then one of these situations applies:

       - The Container has no upper bound on the CPU resources it can use. 
         Then Container could use all of the CPU resources available on the Node where it is running.

       - The Container is running in a namespace that has a default CPU limit, 
         and the Container is automatically assigned the default limit. 
         Cluster administrators can use a LimitRange to specify a default value for the CPU limit.

    If you do not specify a memory limit for a Container, one of the following situations applies:

       - The Container has no upper bound on the amount of memory it uses. 
         Then Container could use all of the memory available on the Node 
         where it is running which in turn could invoke the OOM Killer. 
         Further, in case of an OOM Kill, a container with no resource limits will 
         have a greater chance of being killed.

       - The Container is running in a namespace that has a default memory limit, 
         and the Container is automatically assigned the default limit.
         Cluster administrators can use a LimitRange to specify a default value for the memory limit.

 ----------------------------------------------------
 apiVersion: v1
 kind: Pod
 metadata:
   name: frontend
 spec:
   containers:
   - name: db
     image: mysql
     env:
     - name: MYSQL_ROOT_PASSWORD
       value: "password"
     resources:
       requests:
         memory: "64Mi"
         cpu: "250m"
       limits:
         memory: "128Mi"
         cpu: "500m"

   - name: memory-demo-ctr
     image: polinux/stress
     resources:
       limits:
         memory: "200Mi"
       requests:
         memory: "100Mi"
     command: ["stress"]
     args: ["--vm", "1", "--vm-bytes", "150M", "--vm-hang", "1"]

   - name: cpu-demo-ctr
     image: vish/stress
     resources:
       limits:
         cpu: "1"
       requests:
         cpu: "0.5"
     args:
     - -cpus
     - "2"
 ----------------------------------------------------

 =========================================================================================
    2 - 4/5          2-4    CKAD - Configuration - Secrets - 18%
 =========================================================================================
  Secrets: This object is used to store sensitive information

  Types of secrets we can create in kubernetes:
    - generic
    - docker-registry
    - tls

  Example:
    first we need convert the secret data base64 encryption

    encryption:

    echo -n 'my-app' | base64
    #o/p: bXktYXBw
    echo -n '39528$vdg7Jb' | base64
    #o/p: Mzk1MjgkdmRnN0pi
   
    decryption:

    echo 'bXktYXBw' | base64 --decode
    #o/p: my-app
    echo 'Mzk1MjgkdmRnN0pi' | base64 --decode
    #o/p: 39528$vdg7Jb

  Manifest file for Secret:
  ------------------secret.yaml-----------------------
   apiVersion: v1
   kind: Secret
   metadata:
     name: app-secret
   data:
     username: bXktYXBw
     password: Mzk1MjgkdmRnN0pi
  ------------------------------------------------
  Note: if we use 'data' feild in the above manifest file. Then we need to do base64 encryption.
        if we use 'stringData' feild in the above manifest file. Then base64 encryption not required.
  
  COMMANDS:

    - To create secret from the manifest file:
        kubectl create -f secret.yaml
    - To see the list of secrets avialable:
        kubectl get secrets
    - To see the detailed view of secret:
        kubectl describe secrets <secret-name>
        ex: kubectl describe secrets app-secret
    - To see the detailed view of secret in YAML format:
        kubectl get secrets <secret-name> -o yaml
        ex: kubectl get secrets app-secret -o yaml
    - To generate YAML manifest file for secret:

       #To create Secret from literals
       kubectl create secret generic <secretName>  --from-literals=<key>=<value>
       ex: kubectl create secret generic app-secret  --from-literals=DB_HOST=mysql \
                                                   --from-literals=DB_USERNAME=admin \
                                                   --from-literals=DB_PASS=PASSword123 #\
                                                  # -o yaml --dry-run  #use this to generate manifest file
      
      #To create Secret from file
       kubectl create secret generic <secretName>  --from-file=<filePath>
       ex: kubectl create secret generic app-secret  --from-file=app_secret.properties #\
                                                    # -o yaml --dry-run  #use this to generate manifest file

      NOTE: if we use '--from-literals', we have to use escape charecters if
            the string data entered has any special charecters.
             
            if we use '--from-file', Then no need to use escape charecters 

            Individual secrets are limited to 1MiB in size

  USAGE:
   
    - Acessing secrets and passing values to env variables from secrets:
   -------------------pod-def.yaml------------------------------------------------------

    apiVersion: v1
    kind: Pod
    metadata:
      name: secret-env-pod
    spec:
      containers:
      - name: mycontainer
        image: redis
        env:
          - name: SECRET_USERNAME
            valueFrom:
              secretKeyRef:
                name: app-secret
                key: username
   -------------------------------------------------------------------------

   - Acessing secrets and passing value to env from secrets:
   -------------------pod-def.yaml------------------------------------------------------

    apiVersion: v1
    kind: Pod
    metadata:
      name: secret-env-pod
    spec:
      containers:
      - name: mycontainer
        image: redis
        envFrom:
        - secretRef:
            name: app-secret
   -------------------------------------------------------------------------

   - This is an example of a Pod that mounts a Secret in a volume:
   -------------------pod-def.yaml------------------------------------------------------

    apiVersion: v1
    kind: Pod
    metadata:
      name: secret-env-pod
    spec:
      containers:
      - name: mycontainer
        image: redis
        volumeMounts:
          - name: foo
            mountPath: "/etc/foo"
            readOnly: true
        volumes:
         - name: foo
           secret:
             secretName: app-secret
      #note: each attribute is created as file in the volumes 
                       # cat /etc/foo/DB_HOST
   -------------------------------------------------------------------------

   - To create secret for docker registry:

      kubectl create secret docker-registry <name> \
      --docker-server=DOCKER_REGISTRY_SERVER \
      --docker-username=DOCKER_USER \
      --docker-password=DOCKER_PASSWORD \
      --docker-email=DOCKER_EMAIL


   - To Create a new TLS secret named tls-secret with the given key pair:
       kubectl create secret tls tls-secret --cert=path/to/tls.cert --key=path/to/tls.key


=========================================================================================
    2 - 5/5          2-5    CKAD - Configuration - Service Accounts - 18%
 =========================================================================================
 ServiceAccounts: 
  - Belongs to application or VM instance  instead of Individual.
  - Each service account is associated with two sets of pub/private key
  - Since it doesn't have usernames and password can't be used to login using browsers.
  - These are two types:
    - Google managed keys and user managed keys.
  - Cloud IAM permissions can be granted to allow other users to impersonate service account.
  - These service accounts offer higher serivce level Objectives than user accounts.
  - Service accounts are not the members of the G-suite Domain unlike user accounts.
  - These service accounts can be attached to users and indirectly user can access the resources
    attached to service accounts  

  NOTE:
    - The service account has to exist at the time the pod is created, or it will be rejected.
    - You cannot update the service account of an already created pod.
    - In kubernetes by deafult a default service account is created.

 Manifest file for Service Account:

 -----------------------------------------------
 apiVersion: v1
 kind: ServiceAccount
 metadata:
    creationTimestamp: 2020-01-20T13:40:02Z
    name: default
    namespace: default
    resourceVersion: "322"
    selfLink: /api/v1/namespaces/default/serviceaccounts/default
    uid: 5c02a25a-3b8a-11ea-ab89-0242ac110028
 secrets:
    - name: default-token-b6bft
 -----------------------------------------------
 NOTE: we can also add imagePullSecret to serviceaccount. Check the original documentation.

 COMMANDS:

 - To create service account:
     kubectl create serviceaccount <serviceaccountname>
 - To see list of service account:
     kubectl get serviceaccounts
 - To see detailed view  of service:
     kubectl describe serviceaccount <serviceaccountname>
 - To view the secret of serviceaccount:
     kubectl describe secret <serviceaccountname>

 USAGE:
 -------------------------------------------------------------
   apiVersion: v1
   kind: Pod 
   metadata: 
     name: myapp-pod   
     labels:
       app: myapp
       type: front-end    
   spec:
     serviceAccount: default
     serviceAccountName: default
     containers:
       - name: nginx-webserver
         image: nginx
         ports:
           - containerPort: 80
-------------------------------------------------------------

=========================================================================================
            3    CKAD - Configuration - Multi-Container Pods - 10%
 =========================================================================================

 MultiContainerPods:
   
    links: https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/

   - In a multi-container pod, each container is expected to run a process that 
     stays alive as long as the POD's lifecycle.

   - For example in the multi-container pod that we talked about earlier that has a 
     web application and logging agent,  both the containers are expected to stay alive at all times. 

   - The process running in the log agent container is  expected to stay alive as long 
     as the web application is running. If any of them fails, the POD restarts.

 Multi containers are dived based on functionality:

      - SideCar:
          - shares the same file System between the containers in POD.
          - Sidecar containers extend and enhance the “main” container, 
            they take existing containers and make them better. 

         -  As an example, consider a container that runs the Nginx web server.  
            Add a different container that syncs the file system with a git repository, 
            share the file system between the containers and you have built Git push-to-deploy. 

            But you’ve done it in a modular manner where the git synchronizer can be built by 
            a different team, and can be reused across many different web servers (Apache, 
            Python, Tomcat, etc).  

            Because of this modularity, you only have to write and test your git synchronizer once 
            and reuse it across numerous apps. 
            And if someone else writes it, you don’t even need to do that.

      - Ambassdor:

          - Ambassador containers proxy a local connection to the world.  
           
          - As an example, consider a Redis cluster with read-replicas and a single write master.  
            You can create a Pod that groups your main application with a Redis ambassador container.  
            The ambassador is a proxy is responsible for splitting reads and writes and 
            sending them on to the appropriate servers.  

            Because these two containers share a network namespace, they share an IP address and 
            your application can open a connection on “localhost” and find the proxy without any 
            service discovery.  

            As far as your main application is concerned, it is simply connecting to a Redis server 
            on localhost.  This is powerful, not just because of separation of concerns 
            and the fact that different teams can easily own the components, 
            but also because in the development environment, you can simply skip the proxy and 
            connect directly to a Redis server that is running on localhost.          


      - Adapter:
         - Adapter containers standardize and normalize output.  
           Consider the task of monitoring N different applications.  
           Each application may be built with a different way of exporting monitoring 
           data. (e.g. JMX, StatsD, application specific statistics) but every monitoring system expects 
           a consistent and uniform data model for the monitoring data it collects.  

           By using the adapter pattern of composite containers, you can transform the heterogeneous
           monitoring data from different systems into a single unified representation by 
           creating Pods that groups the application containers with adapters that know how to do the 
           transformation. 

           Again because these Pods share namespaces and file systems, the coordination of these 
           two containers is simple and straightforward.
           


 NOTE: implementation is same for all the above containers.

   - Example for multi container pods:
     -----------------------------------------------------------------------------
      apiVersion: v1
      kind: Pod
      metadata:
        name: yellow
      spec:
        containers:
          - name: simple-webapp
            image: nginx

          - name: log-agent
            image: log-agent

     -----------------------------------------------------------------------------
 
   - InitContainers:
        - Sometimes you may want to run a process that runs to completion in a container. 
        - For example a process that pulls a code or binary from a repository that will be 
          used by the main web application.  That is a task that will be run only one time when 
          the pod is first created Or a process that waits  for an external service or database to 
          be up before the actual application starts. That's where initContainers comes in.
    
        - You can configure multiple such initContainers as well, like how we did for multi-pod containers. 
        - In that case each init container is run one at a time in sequential order.
        - If any of the initContainers fail to complete, then Kubernetes restarts the Pod repeatedly 
          until the Init Container succeeds.

      -------------------------------------------------------------------------------
        ---
         apiVersion: v1
         kind: Pod
         metadata:
           name: myapp-pod
           labels:
            app: myapp
         spec:
           containers:
             - name: myapp-container
               image: busybox:1.28
               command: ['sh', '-c', 'echo The app is running! && sleep 3600']
           initContainers:
             - name: init-myservice
               image: busybox:1.28
               command: ['sh', '-c', 'until nslookup myservice; do echo waiting for myservice; sleep 2; done;']
             - name: init-mydb
               image: busybox:1.28
               command: ['sh', '-c', 'until nslookup mydb; do echo waiting for mydb; sleep 2; done;']

      -------------------------------------------------------------------------------

 =========================================================================================
            4 - 1,2/4  4-1 4-2  CKAD -  Observability - ReadinessProbe - LivenessProbe- 18%
 =========================================================================================

   ReadinessProbe and LivenessProbe:

    - A Probe is a diagnostic performed periodically by the kubelet on a Container. 
    - To perform a diagnostic, the kubelet calls a Handler implemented by the Container. 
    - There are three types of handlers:

         - ExecAction: 
             - Executes a specified command inside the Container. 
             - The diagnostic is considered successful if the command exits with a status code of 0.

         - TCPSocketAction: 
             - Performs a TCP check against the Container’s IP address on a specified port. 
             - The diagnostic is considered successful if the port is open.

         - HTTPGetAction: 
             - Performs an HTTP Get request against the Container’s IP address 
               on a specified port and path. 

             - The diagnostic is considered successful if the response has a status code 
               greater than or equal to 200 and less than 400.

    - The kubelet can optionally perform and react to three kinds of probes on running Containers:

        livenessProbe: 
            - Indicates whether the Container is running. 
            - If the liveness probe fails, the kubelet kills the Container, and the Container 
              is subjected to its restart policy. 
            - If a Container does not provide a liveness probe, the default state is Success.
            NOTE:
               - If the process in your Container is able to crash on its own whenever 
                 it encounters an issue or becomes unhealthy, then specify a liveness probe, 
                 and specify a restartPolicy of Always or OnFailure.


        readinessProbe: 
            - Indicates whether the Container is ready to service requests. 
            - If the readiness probe fails, the endpoints controller removes the Pod’s IP address 
               from the endpoints of all Services that match the Pod. 
            - The default state of readiness before the initial delay is Failure. 
            - If a Container does not provide a readiness probe, the default state is Success.
            NOTE:
                - If your Container needs to work on loading large data, configuration files, 
                  or migrations during startup, specify a readiness probe.
                - Also, If you’d like to start sending traffic to a Pod only when a probe succeeds, 
                  specify a readiness probe

        startupProbe: 
            - Indicates whether the application within the Container is started. 
            - All other probes are disabled if a startup probe is provided, until it succeeds.
            - If the startup probe fails, the kubelet kills the Container, and the Container 
              is subjected to its restart policy. 
            - If a Container does not provide a startup probe, the default state is Success.

        NOTE:

            - If your Container usually starts in  more than 
              initialDelaySeconds + failureThreshold × periodSeconds: 
              you should specify a startup probe that checks the same endpoint as the liveness probe. 
              The default for periodSeconds is 30s.

            - You should then set its failureThreshold high enough to allow the Container to start, 
              without changing the default values of the liveness probe. 
              This helps to protect against deadlocks.

  
   Example:
    -----------------------------------------------------------------------
    apiVersion: v1
    kind: Pod
    metadata:
      labels:
        test: liveness
      name: liveness-exec
    spec:
      containers:
      - name: liveness
        image: k8s.gcr.io/busybox
        args:
        - /bin/sh
        - -c
        - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600
        livenessProbe:
          exec:
            command:
            - cat
            - /tmp/healthy
          initialDelaySeconds: 5
          periodSeconds: 5
      
     ------------------------------------------------------------------------
     NOTE:
        In the above Maifest file:
        - The 'periodSeconds' field specifies that the kubelet should 
          perform a liveness probe every 5 seconds. 

        - The 'initialDelaySeconds' field tells the kubelet that it should 
          wait 5 second before performing the first probe


     Probes Configurations:

         - initialDelaySeconds: 
             - Number of seconds after the container has started before liveness or readiness 
               probes are initiated. 

             - Defaults value: 0 seconds. 
             - Minimum value is 0.

         - periodSeconds: 
              - How often (in seconds) to perform the probe. 

              - Defaults value: 10 seconds. 
              - Minimum value is 1.

         - timeoutSeconds: 
              - Number of seconds after which the probe times out. 

              - Defaults value: 1 second. 
              - Minimum value is 1.

         - successThreshold: 
              - Minimum consecutive successes for the probe to be considered 
                successful after having failed. 

              - Defaults value: 1. 
              - Must be 1 for liveness. 
              - Minimum value is 1.

         - failureThreshold: 
              - When a Pod starts and the probe fails, Kubernetes will try 
                failureThreshold times before giving up. 
              - Giving up in case of liveness probe means restarting the container. 
              - In case of readiness probe the Pod will be marked Unready. 

              - Defaults value: 3. 
              - Minimum value is 1


  - Example with readinessProbe, livenessProbe, startupProbe:
 ---------------------------pod-def.yaml---------------------------------------
    apiVerision: v1
    kind: Pod
    metadata:
      name: my-legacy-app
    spec:
      containers:
       - name: legacy
         image: legacy:v1

         readninessProbe:
           httpGet:
             path: /api/ready
             port:8080
         # readninessProbe:
         #   tcpSocket:
         #     port:8080
         # readninessProbe:
         #   exec:
         #     command:
         #       - cat 
         #       - /app/is_ready

         livenessProbe:
           httpGet:
             path: /api/ready
             port:8080
           initialDelaySeconds: 10
           periodSeconds: 5
           failureThreshold: 8
         # livenessProbe:
         #   tcpSocket:
         #     port:8080
         #   initialDelaySeconds: 10
         #   periodSeconds: 5
         #   failureThreshold: 8
         # livenessProbe:
         #   exec:
         #     command:
         #       - cat 
         #       - /app/is_ready
         #   initialDelaySeconds: 10
         #   periodSeconds: 5
         #   failureThreshold: 8

         startupProbe:
          httpGet:
            path: /healthz
            port: liveness-port
          failureThreshold: 30
          periodSeconds: 10

  ------------------------------------------------------------------------
  NOTE:
    - To deal with legacy applications that might require an additional startup time 
      on their first initialization. 

    - In such cases, it can be tricky to set up liveness probe parameters without 
      compromising the fast response to deadlocks that motivated such a probe. 

    - The trick is to set up a startup probe with the same command, HTTP or TCP check, 
      with a 'failureThreshold * periodSeconds' long enough to cover the worse case startup time.

    - The application will have a maximum of 5 minutes (30 * 10 = 300s) to finish its startup. 
      Once the startup probe has succeeded once, the liveness probe takes over to provide a 
      fast response to container deadlocks. 

    - If the startup probe never succeeds, the container is killed after 300s and subject to 
      the pod’s restartPolicy.

  
   