---
 RHCSA: 3 years
  Essential-tools:
   - BASIC Commands:
       - basic commands list:
            - ls
            - mv
            - touch
            - cat
            - mkdir
            - rm
            - cp
            - vi
            - vim
            - man
            - ifconfig
            - hostname
            - hostnamectl
            - date
            - timedatectl
            - cal
            - history
            - more
            - grep
            - >
            - >>
            - <
            - redirecting error and output:
               cat file1.txt &> output-file1.txt #&> redirecting output/error or both
               cat file1.txt 1> output-file1.txt 2>&1 #redirecting error and output
               cat file1.txt 1> /dev/null 2>&1 #redirecting error and output to null # destroying data
            - |
            - wc



       - To see the n/w interfaces:
             ifconfig
             ip addr show

       - To see list of files:
          - to see detailed info of folders/directories and files:
              ls -l 
          - to see hidden files:
              ls -al
          - to sort the file based on alphabetical order:
              ls -lr
          - to sort the file based on  reverse alphabetical order or time created:
              ls -lrt
          - to see the files in a tre view:
              ls -R
       - To set the hostname:
              hostnamectl set-hostname <hostname> # ex: hostnamectl set-hostname web.company.com
       - To see time date and time zone:
              timedatectl
       - To set the timezone:
              timedatectl set-timezone <timezone name>
              #note: type without quotes 'timedatectl set-timezone' and then hit Tab twice to see list of timezones available
       - To print time on screen:
            - to print in 12 hrs format:
               date +%r
            - to print in 24 hrs format:
               date +%R
       - To print calender on screen:
            - to print calender of current month:
               cal 
            - to print calender of year:
               cal 2019
            - to print calender of month:
               cal 08 2019
       - To see the list of previous commands executed: 
          history # by default it stores upto tha last 1000 commands.
            - to see the history file size:
               echo $HISTFILESIZE
            - to set the history file size to (say 2000):
               echo HISTFILESIZE=2000
            - to use the commands shown in history:
                history # and then below command
                !<command-no> #ex: if we want to run 20th command then # type !20 and hit enter
            - to show in pages:
                history | more
            - to see the last 5 commands run:
                history 5
            - to use last command starting with a letter :
               !c # for command starting with c
               !w # for command starting with w
            - to search for a command in history:
                press CTRL+R on keyboard and start typing
            - to run the recent last command:
                !!
            - to set the print format for history:
               export HISTTIMEFORMAT='%F %T '
            - to see the any linux OS version:
               cat /etc/*-release
            - to see the redhat OS version:
               cat /etc/readhat-release
            - to print the kernel name:
               uname -s
            - to print the node name:
               uname -n 
            - to see the cpu info:
               cat /proc/cpuinfo #or lscpu
            - to see the memory details:
               cat /proc/meminfo #or free -h 
            - to see the list of running process:
               top
            - to see the virtual memory:
               vmstat

   - Keyboard shortcuts:
      - CTRL + u  # to clear the command and put the cursor at starting position
      - CTRL + arrow key # to mov e the cursor tot starting position of the each word
      - up/down arrow  #to see the previous command run
      - CTRL + l # to clear the screen
      - CTRL + k 
      - CTRL + c # to stop the running process
      - CTRL + r # to search for previous command
   - I/O REDIRECTION
   - GREP
   - access remote systems SSH:
     ssh: to connect to remote systems 
      ssh user@IPaddress
     file transfers:
       telnet: no security no encryption
       ftp: no security no encryption
       scp: scp <file-name> user@IP:~
       sftp: sftp user@IP 
        - get: to download file
        - put: to upload file
       
   - LOG-IN AND SWITH USERIN MULTI USER TARGETS
   - UN/ARCHIVE , UN/COPMRESS UN/PACK files using tar.gz,star,gzip,bgip/2
       - gzip:  
            #used to compress only files and can't compress directories         
            create .gz file
             #to compress files
             gzip filename
             #to see compression details
             gzip -l filename 
             # to uncompress 
             gzip -d filename
        - gunzip :
           - used to uncompress files
             gunzip filename
        - tar: used to compress files and directories
           #to create a compressed file
             tar -cvf filename.tar directory/ file1 file2
           #to view files in tar
             tar -tvf filename.tar
           #to untar .tar files
             tar -xvf filename.tar
           #to untar tar.gz 
             tar -xvzf filename.tar
             
   - create and edit txt files:
      vi editor  
       - press i - to go to insert mode
       
       - go to x mode and then 
           press R to go to REPLACE mode and type on the exisiting chars and it will be replaced
           press dd - to cut and then p to paste
           press y - to copy the lines and then p to paste
           gg - to go to start of file
           shft+GG to go to end of file
           cc to cut the line and go to insert mode
           type colon : and then below
           :u to undo 
           :/searchword to find the matching lines #ex: if want to find hello in the test then
           :/hello
           :set nu  #to show line numbers
           :+line number #to go to next line number ex: :/+50 to go to 55oth line from present line where the cursor exists
           :%s/hello/how #to replace first occurance of word 'hello' with 'how'
           :%s/hello/how/g #to replace all occurances in the file
           :q! #to quit without saving
           :wq! #to write and close the file
           
       
   - create hard and soft links:
     soft link:
      ln -s <file> filename
     hard link:
      ln <file> <filename>    
      
   - List , set changes standards UGO/RWX PREMISSIONS -UNMASK:
     file ownership permission: these are given to u g o
          u - user/owner
          g - group
          o - others 
          chown user:group -R <directory/> # to give access to u , g for directory and sub directories
          
         file operations: r w x s t 
          normal mode:          
           chmod o+rwx <filename> #to give permissions to others rwx
           chmod o-rwx <filename> #to remove permissions to others rwx
           chmod u+rwx <filename> #to give permissions to user rwx
           chmod u-rwx <filename> #to remove permissions to user rwx
           chmod ug+rwx <filename> #to give permission to user and group rwx
           chmod u+rws <filename> #to give permissions to user rws
           chmod a+rwx <filename> #to give permission to user and group and others rwx
           chmod o+rwx -R <filename> #to give permissions to others rwx including sub directories
           chmod +t <filename> #to set sticky bit to user
         octal Mode:
           rwx - read write execute
           r = 4 
           w = 2 
           x = 1
           no permission = 0
          
           chmod 777 <filename> #to give full access rwxrwxrwx to user group others
           chmod 764 <filename> #to give full access rwxrwxrwx to user, rw to group, r to others
           chmod 764 -R <filename> #to give full access rwx to user, rw to group, r to others
           including all the files inside directory
           chmod 4777 <filename> #to give full access rwsrwxrwx to user group other and set uid to user
           chmod 2777 <filename> #to give full access rwxrwSrwx to user group other and set gid to group
           chmod 6777 <filename> #to give full access rwsrwSrwx to user group other and set uid and gid to user and group
           chmod 1777 <filename> #to give full access rwxrwxrwT to user group other and sticky bit only to user
           chmod 7777 <filename> #to give full access rwx to user group other and set and sticky bit to user,owner,group
         
         t - sticky bit:
             it is used to prevent premissions for other users. other than owner no one can modify it
         s - set uid/ gid:     
           user/owner permission bit means it runs with that set id
   - locate Read and use System documentation with man, info and  usr/share/doc
       mandb:
       apropos:
       info:
       usr/share/doc:
       usr/share/info:
       updatedb: and then use locate to find the file
       locate: this will work if we use updatedb command before it
       which:
       whereis:
       rpm -qd <packagename> #q query and d doc
       find:
      
   - finding files with locate and find
        find /home/ec2-user  -max-depth 3 -name "*.sh" -type f -mtime +50  # find file upto 3 sub directores +50 more than 50 days ago, -50 leass than 50 days
         
        find /home/ec2-user  -max-depth 3 -name "*.sh" -type f -mtime 50
  Running-System-Operations:
   - boot/reboot/shutdown systems
     runlevel
      0 – Halt
      1 – Single-user text mode
      2 – Not used (user-definable)
      3 – Full multi-user text mode
      4 – Not used (user-definable)
      5 – Full multi-user graphical mode (with an X-based login screen)
      6 – Reboot
      
      
       init 0 shutdown
       init 6 reboot
       #To shutdown now
       shutdown -h now
       
       #To poweroff after shutdown
       shutdown -p now
       
       #To cancel pending shutdown
       shutdown -c 
       
       #To send messages during shutdown
       shutdown -k "your message"
       
       #To restart after shutdown 
       shutdown -r now
       
       #To shutdown at  particular time
       shutdown -h 08:30 " your message" 
       
       #To shutdown in 5 min..
       shutdown -h +5 "system will be shutdown in 5min.."
       
       Usage: shutdown [OPTION]... TIME [MESSAGE]
       Bring the system down.

        Options:
         -r                          reboot after shutdown
         -h                          halt or power off after shutdown
         -H                          halt after shutdown (implies -h)
         -P                          power off after shutdown (implies -h)
         -c                          cancel a running shutdown
         -k                          only send warnings, don't shutdown
         -q, --quiet                 reduce output to errors only
          -v, --verbose               increase output to include informational messages
           --help                  display this help and exit
          --version               output version information and exit

       
   - boot system into differetn targets
       #to check the current target 
        systemctl get-default
      #to see list of targets 
        systemctl list-units --type=target
        
        
   - interrupt the boot process and gain access to system
   - adjust process priority and kill process
   - locate a dn interpret system log files
   - start/stop/check the status of system network services
   - securely transfer files between systems
  Configure-local-storage:
   - list create/delete partitions on MBR/GPT disks
   - using LVM
   - Configure systems to mount FILE SYSTEMS at boot by using UUID or label
   - Add new partition and logical volumes and swap to a system NON destructively
  Create and configure FILE SYSTEMS:
   - Create/mount/unmount  and use VFAT/EXT4/XFS File Systems
   - Mount/Unmount CIFS/NFS network file systems
   - Extend existing logical volumes
   - create and confgure set -GID directories and colloborations
   - Create and manage ACL
   - Diagonise and correct File permission problems
  Deploy Configure and Maintain System:
   - Configure networking and host name resolutions statically/dynamically :troubles
   - networking and host name resolutions statically/dynamically : Network Manager
   - networking and host name resolutions statically/dynamically : host Name configuration
   - Schedule task using at and cron
   - Start/stop/configure services automatically at boot
   - Configre systems to boot into specific target automatically
   - install RHEL automatically using quick start
   - Configure a physical machine to host virtual guests
   - configure a sytem to use Time Services
   - Install and update packages from redhat n/w YUM/RPM REPO 
   - Managing repositories
   - Configuring local repositories
   - Configuring local repositories using GPG keys
   - Update kernel package appropriately to ensure bootable system
   - modify system boot loader
  Manage Users and Groups:
   - Create/delete/modify Local user Accounts
   - Change passwords and adjust passwords aging for specific users
   - Create/delete/modify Local groups and memberships
   - Using set GID on directories
  Manage Securities:
   - Configure firewall settings usign availabel firewall utilities
   - Configure key based authentication for SSH
   - Intro to SE Linux
   - Set Enforcing and permissive modes for SE Linux
   - List and identify SELinux Files and Process Contexts
   - Restore default file Contexts
   - Use boolean Setting to modify Systems SELinux Settings
   - Diagnose and address Routine SELinux Policy Violations
---
 LFCS: 3 years
  Essential Commands – 25%:
   - Log into local & remote graphical and text mode consoles
   - Search for files
   - Evaluate and compare the basic file system features and options
   - Compare and manipulate file content
   - Use input-output redirection (e.g. >, >>, |, 2>)
   - Analyze text using basic regular expressions
   - Archive, backup, compress, unpack, and uncompress files
   - Create, delete, copy, and move files and directories
   - Create and manage hard and soft links
   - List, set, and change standard file permissions
   - Read, and use system documentation
   - Manage access to the root account
   
  Operation of Running Systems – 20%:
   - Boot, reboot, and shut down a system safely
   - Boot or change system into different operating modes
   - Install, configure and troubleshoot bootloaders
   - Diagnose and manage processes
   - Locate and analyze system log files
   - Schedule tasks to run at a set date and time
   - Verify completion of scheduled jobs
   - Update software to provide required functionality and security
   - Verify the integrity and availability of resources
   - Verify the integrity and availability of key processes
   - Change kernel runtime parameters, persistent and non-persistent
   - Use scripting to automate system maintenance tasks
   - Manage the startup process and services (In Services Configuration)
   - List and identify SELinux/AppArmor file and process contexts 
   - Manage Software 
   - Identify the component of a Linux distribution that a file belongs to
   
  User and Group Management – 10%:
   - Create, delete, and modify local user accounts
   - Create, delete, and modify local groups and group memberships
   - Manage system-wide environment profiles
   - Manage template user environment
   - Configure user resource limits
   - Manage user privileges
   - Configure PAM
  
  Networking – 12%:
   - Configure networking and hostname resolution statically or dynamically
   - Configure network services to start automatically at boot
   - Implement packet filtering
   - Start, stop, and check the status of network services
   - Statically route IP traffic
   - Synchronize time using other network peers
  
  Service Configuration – 20%:
   - Configure a caching DNS server
   - Maintain a DNS zone
   - Configure email aliases
   - Configure SSH servers and clients
   - Restrict access to the HTTP proxy server
   - Configure an IMAP and IMAPS service
   - Query and modify the behavior of system services at various operating modes
   - Configure an HTTP server
   - Configure HTTP server log files
   - Configure a database server
   - Restrict access to a web page
   - Manage and configure containers
   - Manage and configure Virtual Machines
  
  Storage Management – 13%:
   - List, create, delete, and modify physical storage partitions
   - Manage and configure LVM storage
   - Create and configure encrypted storage
   - Configure systems to mount file systems at or during boot
   - Configure and manage swap space
   - Create and manage RAID devices
   - Configure systems to mount file systems on demand
   - Create, manage and diagnose advanced file system permissions
   - Setup user and group disk quotas for filesystems
   - Create and configure file systems

---
Scripting:
 echo $PATH
 echo PATH=$PATH:$(pwd)
 
 ----
 EXAMPLE-1: read inputs from command line
   
   #!/bin/bash   
   echo -n you name:
   read NAME
   echo -n your age:
   read AGE
   echo
   echo ===========emp details====
   echo name: $NAME
   echo Age: $AGE
 ----
 EXAMPLE-2: read inputs from command and hide them while typing
    #!/bin/bash   
    read -p "YOUR NAME:" NAME
    read -sp "YOUR PASSWORD:" PASS #sp hides entered text
    echo
    echo "YOUR NAME: $NAME , YOUR PASSWORD: $PASS"
 ----
 EXAMPLE-3:  read inputs from file
    #!/bin/bash
    read FILEDATA < /etc/hosts
    echo HOSTNAME: $FILEDATA
 ---  
 EXAMPLE-4: calculate time elapsed
   #!/bin/bash
   #(date %s) gives the time in seconds , this is no. of seconds counte from jan 1 1970
   START=$(date +%s) 
   CURRENT_DIR=$(pwd)
   END=$(date +%s) 
   
   #end time measurent
   DIFFERENCE=$(( START - END ))
   echo "Time Elapsed: $DIFFERENCE"
 ---
  Example-5: MATH OPERATIONS
  #!/bin/bash
   NUM=5
   
   #-------let----
   let RES=NUM+5
   echo "result from let: $RES"
   
   #--------(( ))----
   RES=$(( NUM + 5 ))
   echo "result from  (( )): $RES"
   
   #------[]-------
   RES=$[ NUM + 5 ] 
   echo "result from  [ ]: $RES"
   
   #-----expr----------
   RES=$(expr  $NUM + 5)
   echo "result from  expr: $RES"
   
   #-------bc----------
   #for floting points
   RES=`echo "$NUM * 1.9 " | bc`
   echo "result from  bc: $RES"

   #power expression
   RES=`echo "$NUM^$NUM" | bc`
   echo "result from  bc for x^y : $RES"
 ---
  EXAMPLE-6: special arguments
    #!/bin/bash
    echo script name: $0
    echo first argument: $1
    echo second argument: $2
    echo all arguments: $@
    echo all arguments: $*
    echo all  no of arguments: $#
    echo print process id: $$
 ---
  EXAMPLE-7: i/o redirections
    #!/bin/bash
    # - STDIN(0)
    # - STDOUT(1)
    # - STDERR(2)
    # 
    cat file1.txt > output-file1.txt #> redirecting output
    cat file1.txt 1>output-file1.txt #1> redirecting output
    cat file1.txt 2>errors-file1.txt #2> redirecting errors
    cat file1.txt 1>output-file1.txt 2>errors-file1.txt
    cat file1.txt &> output-file1.txt #&> redirecting output/error or both
    cat file1.txt 1> output-file1.txt 2>&1 #redirecting error and output
    # < redirecting input 
    wc -l < output-file1.txt #o/p = no. of lines
    wc -l  output-file1.txt #o/p = no. of lines and filename
    cat output-file1 | head -5 | tail -3 | wc -l #prints top 5 lines and then picks bottom 2 lines and gives no of lines count 2
 ---
  EXAMPLE-8: EXIT STATUS
    #!/bin/bash
    #exit status code 0-255, if we  give exit 256 then exit code will be 0 again
    #exit code 0 , previous commnd is sucessful other than 0 , it's an error
    NUM=1
    let NUM++    
    let NUM++    
    echo NUM: $NUM
    exit 0
    let NUM++    
    let NUM++    
    echo NUM: $NUM
    exit 257
    let NUM++    
    let NUM++    
    echo NUM: $NUM

 ---
  EXAMPLE-9: numbers comparsions
    #!/bin/bash
    #------------------------------
    # -eq #equal
    # -ne #not equal
    # -gt #greater than
    # -lt #less than    
    # -ge #greater than equal to 
    # -le #less than equal to
    #------------------------------
    # &&  # logical AND
    # ||  # logical OR
    # !   # logical NOT
    #-------------------------------
    VAR=$1

    if [ $VAR = 5 ] && [ $VAR -gt 0 ]; then
     echo "welcome $VAR"

    else
     echo "try again" 

    fi

    if [ $VAR == 10 -o $VAR -gt 7 ]; then
     echo "hello ${VAR}"

    elif [ $VAR -eq 8  ||  $VAR -eq 9 ]; then
     echo " HELLO $(VAR)"

    else
     echo "TRAY AGAIN"

    fi
 ---
  EXAMPLE-10: string comparsions
    #!/bin/bash
    [ "$STR1" = "$STR2" ]     [ "$STR1" = "HELLO" ]
    [ "$STR1" != "$STR2" ]

     [[ $STR1 = $STR2 ]]  [[ $STR1 = "hello" ]]
     [[ $STR1 != $STR2 ]] [[ $STR1 != "hello" ]]

     [[ -z $STR1]] [-z "$STR1"] #-z checks if empty
     [[ -n $STR1]] [-n "$STR1"] #-n checks if not-empty
    

 ---
  EXAMPLE-11: wildcards
    #!/bin/bash

    hel? --> helo,  hell, help ..

    hel* --> hello, helped, ...

    file[0-2]  --> file0, file1, file2 

    [hd]ello --> hello or dello

    {*.txt, *.pdf} --> hello.pdf, help.txt ..

    file[!1] --> file2, file3 , file4 ..

    ^hello --> line starts with hello
    hello$ --> lineends with hello
    file[^12345] --> other than mentionde in that square brackets 
                 --> file6, file7, ....

    [0-9]{3} --> 123, 456, 234 ...   #3 digited number
    [0-9]{1,3} --> 11, 123, 456 ...  #3 digited number
    [0-9]{3,} --> 111, 1234, 456242 ...  #3 or more digited number
    file1+ --> file1, file11, file123.. But not file


 ---
  EXAMPLE-12: create files using loops
   #!/bin/bash
    echo "creating 1-30 files" 
    for i in {1..30};
    do 
      touch file$i.txt;
      touch file$i.img;
    done
 ---
  EXAMPLE-13: backup_script
   #!/bin/bash
   PROD=/home/ec2-user/
   DEST=/home/ec2-user/backup
   DATE=$(date +%Y-%m-%d_%H_%M_%S)
   mkdir -p $DEST/$DATE
   cp -R $PROD/*.txt $DEST/$DATE

   if [ $? -eq 0]
     echo "BACKUP DONE!"
   else
     echo "BACKUP FAILED! Something went wrong!"
     exit 1
   fi
 ---
  EXAMPLE-14: file comparsions
   #!/bin/bash
   #=============FILE======================
   FILE1=/etc/hosts
   FILE2=/home/anurag/1.txt
   [ -e $FILE1 ]                 #here 'hosts' is a file 
   [ -e /home/anurag/1.txt]  #here '1.txt' is the file.
   [ -e FILE1 ] 
   [ -e FILE2 ] 
   -e    #to check file exists
   -r    #to check whether  file is readable
   -w    #to check whether  file is readable
   -x    #to check whether  file is executable
   -d    #to check whether  file is directory
   -f    #to check whether  file exists and is regular file
   -s    #to check whether  file exists and is not empty
   -L    #to hekc if it holds path of symb link

 ---
  EXAMPLE-15: LOOPS 
   #!/bin/bash
   #PRINT 1-10 NUMBERS USING FOR LOOP
   for((i=0;i<10;i++))
   do
     echo $i
   done

   #Add date inside all the text files..
   for FILE in *.txt
   do 
     echo $(date) >> $FILE
   done

   #print the arguments line by line "$@" OR $*
   COUNT=1
   for ARG in "$@"
   do 
     echo $COUNT : $ARG
     let COUNT++
   done

   #print the arguments in one line "$*"
   COUNT=1
   for ARG in "$*"
   do 
     echo $COUNT : $ARG
     let COUNT++
   done

   #TO CHECK INTER FEILD SEPARATOR
   set | grep ^IFS #O/P SHOWN BELOW
   #IFS=$' \t\n'
 ---
  EXAMPLE-16: WHILE LOOP
  #!/bin/bash
   #Print 10 to 2 
    COUNT=10
    while (( $COUNT != 1 )) # [ $COUNT -ne 1 ] # [[ $COUNT -ne 1 ]] # [[ $COUNT != 1 ]] # [ $COUNT -ne 1 ]
    do 
      echo $COUNT
      let count--
    done
   
   #PRINT line number for files 
    COUNT=1 
    FILENAME=$1
    while read line
    do
     echo "$COUNT : $line"
     let COUNT++
    done < "$FILENAME"  #we will get ambiguous redirect error if we dont use "" here if file name has spaces
  
   #PRINT line number for files 
    COUNT=1 
    FILENAME=$1
    cat "$FILENAME" |   #we will get ambiguous redirect error if we dont use "" here if file name has spaces
    while read line
    do
     echo "$COUNT : $line"
     let COUNT++
    done

 ---
  EXAMPLE-17: ARRAYS

     #!/bin/bash
     ARRAY=(one two three)
     echo value of first item: ${ARRAY[0]} #FIRST value
     echo value of first item: ${ARRAY[1]} #SECOND value
     echo all values: ${ARRAY[@]} # ALL values
     echo all values: ${ARRAY[*]} # ALL values in array delimied by IFS (Internal feild separator) # set | grep ^IFS #O/P SHOWN AS #IFS=$' \t\n'
     echo all index values: ${!ARRAY[@]} # ALL index values
     echo "(length/no. of items) of array: ${#ARRAY[@]}" # no. of items in array
     echo length of first value in aray: ${#ARRAY[0]} # length of FIRST value

 ---
  EXAMPLE-18: ARRAYS EXAMPLES to print list of files from array and its wrtiable status

   #!/bin/bash
    #ARRAY=($(ls *.txt))
    ARRAY=($(ls))
    COUNT=1
    echo -e "s.no. \t file name \t writable "
    for FILE in "${ARRAY[@]}"
    do
      echo -n  " $COUNT "
      echo -n " ${FILE} "
     if [ -w $FILE ]; then
       echo -e "\t yes"
     else
       echo -e "\t no"
     fi
     let COUNT++
    done
 ---
  EXAMPLE-19: FUNCTIONS
    #!/bin/bash
    function addition {
      local VAR1=$1
      local VAR2=$2
      let RESULT=VAR1+VAR2
      echo "$1 + $2 = $RESULT"
    }
    echo -n "enter FIRST number:"
    read VAR1
    echo -n "enter SECOND number:"
    read VAR2
    addition $VAR1 $VAR2 #function invoke
 ---
  EXAMPLE-20: sed -STREAM EDITOR
    #!/bin/bash
    -a  #append the text after a line
    -d  # delete the pattern space
    -i  # insert the text
    -p  # print the pattern space
    -q  # quit exit without any processing
    -n  # disable automatic printing
    -e  script # add script
    -r # used for extended redular expression
     s/regexp/replacement/[flags] # substitute regexp with replacement text.






